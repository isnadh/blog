<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lujji</title>
  <subtitle>embedded stuff</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://lujji.github.io/blog/"/>
  <updated>2017-02-01T01:21:04.227Z</updated>
  <id>http://lujji.github.io/blog/</id>
  
  <author>
    <name>lujji</name>
    <email>lujji at protonmail com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTTP Server with WebSockets on ESP8266</title>
    <link href="http://lujji.github.io/blog/esp-httpd/"/>
    <id>http://lujji.github.io/blog/esp-httpd/</id>
    <published>2017-01-30T20:11:00.000Z</published>
    <updated>2017-02-01T01:21:04.227Z</updated>
    
    <content type="html"><![CDATA[<p>This article will cover implementing a basic HTTP server on top of LwIP for ESP8266 and dive into the implementation of WebSockets.</p>
<a id="more"></a>
<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>ESP8266 is an extremely popular device. Chances are, at some point you even bought a few modules for some “future project”. That’s exactly what I did, and for a long time I didn’t find any application for this device.</p>
<h2 id="Contents"><a href="#Contents" class="headerlink" title="Contents:"></a>Contents:</h2><ul>
<li><a href="#The-Hardware">The Hardware</a></li>
<li><a href="#Simple-HTTP-server">Simple HTTP server</a></li>
<li><a href="#WebSockets">WebSockets</a><br>– <a href="#Opening-handshake">Opening handshake</a><br>– <a href="#Transmitting-data">Transmitting data</a><br>– <a href="#Closing-connection">Closing connection</a></li>
<li><a href="#Demo">Demo</a></li>
</ul>
<hr>
<h2 id="The-Hardware"><a href="#The-Hardware" class="headerlink" title="The Hardware"></a>The Hardware</h2><p>At first glance, ESP8266 looks quite attractive: 32-bit processor, decent amount of RAM, up to 4MB external flash for user code. But once you dive into the specifics of the device, you immediately start facing it’s problems: the documentation is rather scarce, power consumption is about 80mA, which is a problem for battery-powered applications, and even though you can have a large external flash, the ESP8266 can only map 1 megabyte of flash into execution space. The rest of the flash may be used for firmware updates and data storage. Overall, the device itself does not instill a lot of confidence. But hey.. it’s cheap.</p>
<img src="/blog/esp-httpd/hardware.jpg" alt="ESP8266" title="ESP8266">
<p>To get the module up and running we need a 3V3 supply rail and a UART-USB converter for programming. Apart from Rx/Tx the following lines need to be connected from the serial cable to the module:</p>
<p><code>RTS</code> -&gt; <code>Reset</code><br><code>DTR</code> -&gt; <code>Boot/GPIO0</code><br><code>3V3</code> -&gt; <code>CH_PD</code></p>
<p>ESP-12E modules already have a pull-up resistor on reset line. Optionally, a pull-up should be installed on <code>GPIO0</code>.</p>
<p>As for the software, there are two versions of SDK from Espressif - one of them is based on FreeRTOS and the other one is based on callbacks. It seems that most development occurs around the non-RTOS version of SDK. At the moment of writing this post, the latest FreeRTOS version provided by Espressif SDK seems to be 7.5.2, while the latest upstream version is 9.0.0. Luckily, <a href="https://github.com/SuperHouse/esp-open-rtos" target="_blank" rel="external">esp-open-rtos</a> addresses this issue. It is a community-developed framework based on the latest version of FreeRTOS, which aims to provide open-source alternatives to the binary blobs of the Espressif SDK.</p>
<h2 id="Simple-HTTP-server"><a href="#Simple-HTTP-server" class="headerlink" title="Simple HTTP server"></a>Simple HTTP server</h2><p>To get a better understanding of how things work, let’s implement the most basic HTTP server. First we need to create a new task called <code>httpd_task</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xTaskCreate(&amp;httpd_task, <span class="string">"http_server"</span>, <span class="number">1024</span>, <span class="literal">NULL</span>, <span class="number">2</span>, <span class="literal">NULL</span>);</div></pre></td></tr></table></figure>
<p>We are going to use LwIP’s <code>netconn</code> API for our demo, <code>&lt;lwip/api.h&gt;</code> needs to be included.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">httpd_task</span><span class="params">(<span class="keyword">void</span> *pvParameters)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> netconn *client = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">struct</span> netconn *nc = netconn_new(NETCONN_TCP);</div><div class="line">    <span class="keyword">if</span> (nc == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Failed to allocate socket.\n"</span>);</div><div class="line">        vTaskDelete(<span class="literal">NULL</span>);</div><div class="line">    &#125;</div><div class="line">    netconn_bind(nc, IP_ADDR_ANY, <span class="number">80</span>);</div><div class="line">    netconn_listen(nc);</div><div class="line">    <span class="keyword">char</span> buf[<span class="number">512</span>];</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">err_t</span> err = netconn_accept(nc, &amp;client);</div><div class="line">        <span class="keyword">if</span> (err == ERR_OK) &#123;</div><div class="line">            <span class="keyword">struct</span> netbuf *nb;</div><div class="line">            <span class="keyword">if</span> ((err = netconn_recv(client, &amp;nb)) == ERR_OK) &#123;</div><div class="line">                <span class="keyword">void</span> *data;</div><div class="line">                <span class="keyword">u16_t</span> len;</div><div class="line">                netbuf_data(nb, &amp;data, &amp;len);</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"Received data:\n%.*s\n"</span>, len, (<span class="keyword">char</span>*) data);</div><div class="line">                <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf),</div><div class="line">                        <span class="string">"HTTP/1.1 200 OK\r\n"</span></div><div class="line">                        <span class="string">"Content-type: text/html\r\n\r\n"</span></div><div class="line">                        <span class="string">"Test"</span>);</div><div class="line">                netconn_write(client, buf, <span class="built_in">strlen</span>(buf), NETCONN_COPY);</div><div class="line">            &#125;</div><div class="line">            netbuf_delete(nb);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Closing connection\n"</span>);</div><div class="line">        netconn_close(client);</div><div class="line">        netconn_delete(client);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The code is pretty straight-forward: we create a new <code>netconn</code>, bind it to port 80 (which is used for HTTP) and start listening for incoming TCP connections. In the main loop of the task we call a blocking function <code>netconn_accept()</code>. Once the connection from client is accepted we log the request to console and generate a response. Response contains a minimal header that is enough for the browser to treat anything after the last <code>\r\n\r\n</code> as HTML page.</p>
<img src="/blog/esp-httpd/http_test.png" alt="Hello, world" title="Hello, world">
<p>When browser requests a page it sends a <code>GET</code> request, which looks like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">GET / HTTP/1.1</div><div class="line">Host: 192.168.100.4</div><div class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:45.0) Gecko/20100101 Firefox/45.0</div><div class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</div><div class="line">Accept-Language: en-US,en;q=0.5</div><div class="line">Accept-Encoding: gzip, deflate</div><div class="line">Connection: keep-alive</div></pre></td></tr></table></figure>
<p>We’re only interested in the first line that contains the URI. To make things a bit more interesting we are going to extract the URI and switch the LED on the device when particular address is requested. We’ll also add some page content just for kicks.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">httpd_task</span><span class="params">(<span class="keyword">void</span> *pvParameters)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> netconn *client = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">struct</span> netconn *nc = netconn_new(NETCONN_TCP);</div><div class="line">    <span class="keyword">if</span> (nc == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Failed to allocate socket.\n"</span>);</div><div class="line">        vTaskDelete(<span class="literal">NULL</span>);</div><div class="line">    &#125;</div><div class="line">    netconn_bind(nc, IP_ADDR_ANY, <span class="number">80</span>);</div><div class="line">    netconn_listen(nc);</div><div class="line">    <span class="keyword">char</span> buf[<span class="number">512</span>];</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *webpage = &#123;</div><div class="line">        <span class="string">"HTTP/1.1 200 OK\r\n"</span></div><div class="line">        <span class="string">"Content-type: text/html\r\n\r\n"</span></div><div class="line">        <span class="string">"&lt;html&gt;&lt;head&gt;&lt;title&gt;HTTP Server&lt;/title&gt;"</span></div><div class="line">        <span class="string">"&lt;style&gt; div.main &#123;"</span></div><div class="line">        <span class="string">"font-family: Arial;"</span></div><div class="line">        <span class="string">"padding: 0.01em 16px;"</span></div><div class="line">        <span class="string">"box-shadow: 2px 2px 1px 1px #d2d2d2;"</span></div><div class="line">        <span class="string">"background-color: #f1f1f1;&#125;"</span></div><div class="line">        <span class="string">"&lt;/style&gt;&lt;/head&gt;"</span></div><div class="line">        <span class="string">"&lt;body&gt;&lt;div class='main'&gt;"</span></div><div class="line">        <span class="string">"&lt;h3&gt;HTTP Server&lt;/h3&gt;"</span></div><div class="line">        <span class="string">"&lt;p&gt;URL: %s&lt;/p&gt;"</span></div><div class="line">        <span class="string">"&lt;p&gt;Uptime: %d seconds&lt;/p&gt;"</span></div><div class="line">        <span class="string">"&lt;p&gt;Free heap: %d bytes&lt;/p&gt;"</span></div><div class="line">        <span class="string">"&lt;button onclick=\"location.href='/on'\" type='button'&gt;"</span></div><div class="line">        <span class="string">"LED On&lt;/button&gt;&lt;/p&gt;"</span></div><div class="line">        <span class="string">"&lt;button onclick=\"location.href='/off'\" type='button'&gt;"</span></div><div class="line">        <span class="string">"LED Off&lt;/button&gt;&lt;/p&gt;"</span></div><div class="line">        <span class="string">"&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;"</span></div><div class="line">    &#125;;</div><div class="line">    <span class="comment">/* disable LED */</span></div><div class="line">    gpio_enable(<span class="number">2</span>, GPIO_OUTPUT);</div><div class="line">    gpio_write(<span class="number">2</span>, <span class="literal">true</span>);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">err_t</span> err = netconn_accept(nc, &amp;client);</div><div class="line">        <span class="keyword">if</span> (err == ERR_OK) &#123;</div><div class="line">            <span class="keyword">struct</span> netbuf *nb;</div><div class="line">            <span class="keyword">if</span> ((err = netconn_recv(client, &amp;nb)) == ERR_OK) &#123;</div><div class="line">                <span class="keyword">void</span> *data;</div><div class="line">                <span class="keyword">u16_t</span> len;</div><div class="line">                netbuf_data(nb, &amp;data, &amp;len);</div><div class="line"></div><div class="line">                <span class="comment">/* check for a GET request */</span></div><div class="line">                <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(data, <span class="string">"GET "</span>, <span class="number">4</span>)) &#123;</div><div class="line">                    <span class="keyword">char</span> uri[<span class="number">16</span>];</div><div class="line">                    <span class="keyword">const</span> <span class="keyword">int</span> max_uri_len = <span class="number">16</span>;</div><div class="line">                    <span class="keyword">char</span> *sp1, *sp2;</div><div class="line"></div><div class="line">                    <span class="comment">/* extract URI */</span></div><div class="line">                    sp1 = data + <span class="number">4</span>;</div><div class="line">                    sp2 = <span class="built_in">memchr</span>(sp1, <span class="string">' '</span>, max_uri_len);</div><div class="line">                    <span class="keyword">int</span> len = sp2 - sp1;</div><div class="line">                    <span class="built_in">memcpy</span>(uri, sp1, len);</div><div class="line">                    uri[len] = <span class="string">'\0'</span>;</div><div class="line">                    <span class="built_in">printf</span>(<span class="string">"uri: %s\n"</span>, uri);</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(uri, <span class="string">"/on"</span>, max_uri_len))</div><div class="line">                        gpio_write(<span class="number">2</span>, <span class="literal">false</span>);</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(uri, <span class="string">"/off"</span>, max_uri_len))</div><div class="line">                        gpio_write(<span class="number">2</span>, <span class="literal">true</span>);</div><div class="line"></div><div class="line">                    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), webpage,</div><div class="line">                            uri,</div><div class="line">                            xTaskGetTickCount() * portTICK_PERIOD_MS / <span class="number">1000</span>,</div><div class="line">                            (<span class="keyword">int</span>) xPortGetFreeHeapSize());</div><div class="line">                    netconn_write(client, buf, <span class="built_in">strlen</span>(buf), NETCONN_COPY);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            netbuf_delete(nb);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Closing connection\n"</span>);</div><div class="line">        netconn_close(client);</div><div class="line">        netconn_delete(client);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Now we have a slightly more interactive server.</p>
<img src="/blog/esp-httpd/http_test2.png" alt="Simple HTTP server" title="Simple HTTP server">
<p>In case your application needs to serve a simple web-page, this approach might be just good enough.</p>
<p>Although implementing an HTTP server from scratch could be a good exercise, I didn’t find it very exciting, so instead of reinventing the wheel I decided to find one that is round enough for my needs.</p>
<p>I decided to use <a href="http://www.nongnu.org/lwip/2_0_0/group__httpd.html" target="_blank" rel="external">httpd</a> from LwIP/contrib for my application. This server is based on callbacks, so it should work with RTOS and non-RTOS SDK.</p>
<h2 id="WebSockets"><a href="#WebSockets" class="headerlink" title="WebSockets"></a>WebSockets</h2><p>WebSocket is a protocol which allows full-duplex communication between between client (like web-browser) and server. This means that we can send small messages back and forth for doing things like toggling pins and reading sensor data without having to refresh the web-page and transfer large amounts of HTTP data all the time. We’ll have to resort to HTTP only once for the opening handshake, after that all the communication is happening on the TCP layer. Everything we need to know in order to implement WebSocket protocol is described in <a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="external">RFC 6455</a>.</p>
<h3 id="Opening-handshake"><a href="#Opening-handshake" class="headerlink" title="Opening handshake"></a>Opening handshake</h3><p>Probably the hardest part. When client wants to open a websocket it sends a specific GET request:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">GET / HTTP/1.1</div><div class="line">Host: server.example.com</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</div></pre></td></tr></table></figure>
<p>The server should generate the following response:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 101 Switching Protocols</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</div></pre></td></tr></table></figure>
<p>The procedure to generate <code>Sec-WebSocket-Accept</code> part is as follows:</p>
<ol>
<li>Take the <code>Sec-WebSocket-Key</code> part</li>
<li>Concatenate it with GUID which is “258EAFA5-E914-47DA-95CA-C5AB0DC85B11”</li>
<li>Calculate SHA-1 hash of the resulting string</li>
<li>Encode hash in base-64 and send to the client</li>
</ol>
<p>Let’s first define some necessary constants inside <code>httpd.c</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> WS_HEADER[] = <span class="string">"Upgrade: websocket\r\n"</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> WS_GUID[] = <span class="string">"258EAFA5-E914-47DA-95CA-C5AB0DC85B11"</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> WS_RSP[] = <span class="string">"HTTP/1.1 101 Switching Protocols\r\n"</span> \</div><div class="line">                      <span class="string">"Upgrade: websocket\r\n"</span> \</div><div class="line">                      <span class="string">"Connection: Upgrade\r\n"</span> \</div><div class="line">                      <span class="string">"Sec-WebSocket-Accept: %s\r\n\r\n"</span>;</div></pre></td></tr></table></figure>
<p>We’ll need to alter <code>http_parse_request()</code> function to support opening handshake. In this context <code>data</code> is the incoming TCP buffer.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (strnstr(data, WS_HEADER, data_len)) &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoded_key[<span class="number">32</span>];</div><div class="line">    <span class="keyword">char</span> key[<span class="number">64</span>];</div><div class="line">    <span class="keyword">char</span> *key_start = strnstr(data, <span class="string">"Sec-WebSocket-Key: "</span>, data_len);</div><div class="line">    <span class="keyword">if</span> (key_start) &#123;</div><div class="line">        key_start += <span class="number">19</span>;</div><div class="line">        <span class="keyword">char</span> *key_end = strnstr(key_start, <span class="string">"\r\n"</span>, data_len);</div><div class="line">        <span class="keyword">if</span> (key_end) &#123;</div><div class="line">            <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (key_end - key_start);</div><div class="line">            <span class="keyword">if</span> (len + <span class="keyword">sizeof</span>(WS_GUID) &lt; <span class="keyword">sizeof</span>(key) &amp;&amp; len &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">/* Concatenate key */</span></div><div class="line">                <span class="built_in">memcpy</span>(key, key_start, len);</div><div class="line">                strlcpy(&amp;key[len], WS_GUID, <span class="keyword">sizeof</span>(key));</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"Resulting key: %s\n"</span>, key);</div><div class="line"></div><div class="line">                <span class="comment">/* Get SHA1 */</span></div><div class="line">                <span class="keyword">unsigned</span> <span class="keyword">char</span> sha1sum[<span class="number">20</span>];</div><div class="line">                mbedtls_sha1((<span class="keyword">unsigned</span> <span class="keyword">char</span> *) key, <span class="keyword">sizeof</span>(WS_GUID) + len - <span class="number">1</span>, sha1sum);</div><div class="line"></div><div class="line">                <span class="comment">/* Base64 encode */</span></div><div class="line">                <span class="keyword">unsigned</span> <span class="keyword">int</span> olen;</div><div class="line">                mbedtls_base64_encode(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;olen, sha1sum, <span class="number">20</span>); <span class="comment">//get length</span></div><div class="line">                <span class="keyword">int</span> ok = mbedtls_base64_encode(encoded_key, <span class="keyword">sizeof</span>(encoded_key), &amp;olen, sha1sum, <span class="number">20</span>);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (ok == <span class="number">0</span>) &#123;</div><div class="line">                    hs-&gt;is_websocket = <span class="number">1</span>;</div><div class="line">                    encoded_key[olen] = <span class="string">'\0'</span>;</div><div class="line">                    <span class="built_in">printf</span>(<span class="string">"Base64 encoded: %s\n"</span>, encoded_key);</div><div class="line"></div><div class="line">                    <span class="comment">/* Send response */</span></div><div class="line">                    <span class="keyword">char</span> buf[<span class="number">256</span>];</div><div class="line">                    <span class="keyword">u16_t</span> len = <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), WS_RSP, encoded_key);</div><div class="line">                    http_write(pcb, buf, &amp;len, TCP_WRITE_FLAG_COPY);</div><div class="line">                    <span class="keyword">return</span> ERR_OK;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"Key overflow\n"</span>);</div><div class="line">                <span class="keyword">return</span> ERR_MEM;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Malformed packet\n"</span>);</div><div class="line">        <span class="keyword">return</span> ERR_ARG;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>Note: I’m using <code>sizeof(buf)</code> quite often to get the array length at compile-time. In this case it works as expected due to the fact that <code>buf</code> is always of char type. A more proper solution is to use <code>sizeof(buf)/sizeof(buf[0])</code> - this way we get the correct result regardless of the data type.</em></p>
<h3 id="Transmitting-data"><a href="#Transmitting-data" class="headerlink" title="Transmitting data"></a>Transmitting data</h3><p>On the client side opening a new WebSocket and listening for incoming messages is just a matter of few lines of javascript:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Open new websocket and register callback */</span></div><div class="line">ws = <span class="keyword">new</span> WebSocket(<span class="string">"ws://192.168.54.29"</span>);</div><div class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123; onMessage(evt) &#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onMessage</span>(<span class="params">evt</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(evt.data);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>When server receives data from a client the payload is <em>always</em> masked (assuming that client’s implementation of the protocol is correct), therefore, we need to unmask the payload before passing it to the user callback. <a href="https://tools.ietf.org/html/rfc6455#page-33" target="_blank" rel="external">Masking algorithm</a> is rather trivial.<br>The first byte of the payload contains an opcode. We’re only going to support text or binary modes and close request. We shall omit continuation frames to keep things simple.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> err_t <span class="title">websocket_parse</span><span class="params">(<span class="keyword">struct</span> tcp_pcb *pcb, <span class="keyword">struct</span> pbuf *p)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *data;</div><div class="line">    data = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*) p-&gt;payload;</div><div class="line">    <span class="keyword">u16_t</span> data_len = p-&gt;len;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (data != <span class="literal">NULL</span> &amp;&amp; data_len &gt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">uint8_t</span> opcode = data[<span class="number">0</span>] &amp; <span class="number">0x0F</span>;</div><div class="line">        <span class="keyword">switch</span> (opcode) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="number">0x01</span>: <span class="comment">// text</span></div><div class="line">            <span class="keyword">case</span> <span class="number">0x02</span>: <span class="comment">// bin</span></div><div class="line">                <span class="keyword">if</span> (data_len &gt; <span class="number">6</span>) &#123;</div><div class="line">                    data_len -= <span class="number">6</span>;</div><div class="line">                    <span class="comment">/* unmask */</span></div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data_len; i++)</div><div class="line">                        data[i + <span class="number">6</span>] ^= data[<span class="number">2</span> + i % <span class="number">4</span>];</div><div class="line">                    <span class="comment">/* user callback */</span></div><div class="line">                    websocket_cb(pcb, &amp;data[<span class="number">6</span>], data_len, opcode);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="number">0x08</span>: <span class="comment">// close</span></div><div class="line">                <span class="keyword">return</span> ERR_CLSD;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ERR_OK;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ERR_VAL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>When server sends data it decides whether or not the payload should be masked. We shall send unmasked data and we won’t support packets larger than 125 bytes for simplicity.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">websocket_write</span><span class="params">(<span class="keyword">struct</span> tcp_pcb *pcb, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *data, <span class="keyword">uint16_t</span> len, <span class="keyword">uint8_t</span> mode)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (len &gt; <span class="number">125</span>)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[len + <span class="number">2</span>];</div><div class="line">    buf[<span class="number">0</span>] = <span class="number">0x80</span> | mode;</div><div class="line">    buf[<span class="number">1</span>] = len;</div><div class="line">    <span class="built_in">memcpy</span>(&amp;buf[<span class="number">2</span>], data, len);</div><div class="line">    len += <span class="number">2</span>;</div><div class="line"></div><div class="line">    tcp_write(pcb, buf, len, TCP_WRITE_FLAG_COPY);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Closing-connection"><a href="#Closing-connection" class="headerlink" title="Closing connection"></a>Closing connection</h3><p>Simply closing a TCP connection is an option, but it’s considered to be an <em>unclean shutdown</em>. When one side wants to close a websocket, it sends a packet which contains   a reason for closing the connection. The other side then echoes this packet back and the connection is considered closed afterwards. Our implementation shall always close the connection with status code <code>1000</code> (normal closure).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> err_t <span class="title">websocket_close</span><span class="params">(<span class="keyword">struct</span> tcp_pcb *pcb)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> buf[] = &#123;<span class="number">0x88</span>, <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0xe8</span>&#125;;</div><div class="line">    <span class="keyword">u16_t</span> len = <span class="keyword">sizeof</span>(buf);</div><div class="line">    <span class="keyword">return</span> tcp_write(pcb, buf, len, TCP_WRITE_FLAG_COPY);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>I created a small project to demonstrate basic functionality. In this demo two sockets are used: one for polling by the client, and second one for streaming data from server.</p>
<img src="/blog/esp-httpd/websocket_demo.png" alt="WebSockets demo" title="WebSockets demo">
<p>Code is available on <a href="https://github.com/lujji/esp-httpd" target="_blank" rel="external">github</a>.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This article will cover implementing a basic HTTP server on top of LwIP for ESP8266 and dive into the implementation of WebSockets.&lt;/p&gt;
    
    </summary>
    
    
      <category term="esp8266" scheme="http://lujji.github.io/blog/tags/esp8266/"/>
    
      <category term="freertos" scheme="http://lujji.github.io/blog/tags/freertos/"/>
    
      <category term="web" scheme="http://lujji.github.io/blog/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Reverse-engineering ST-Link firmware - Part 2</title>
    <link href="http://lujji.github.io/blog/reverse-engineering-stlink-firmware-part2/"/>
    <id>http://lujji.github.io/blog/reverse-engineering-stlink-firmware-part2/</id>
    <published>2016-10-17T00:00:00.000Z</published>
    <updated>2016-10-17T23:00:28.436Z</updated>
    
    <content type="html"><![CDATA[<p>This is the second part of ST-Link reverse-engineering, where I cover dumping the firmware, extracting and reverse-engineering the bootloader, and finally, patching the bootloader in order to disable Level 1 protection.</p>
<a id="more"></a>
<hr>
<h2 id="Dumping-the-bootloader"><a href="#Dumping-the-bootloader" class="headerlink" title="Dumping the bootloader"></a>Dumping the bootloader</h2><p>Dumping the firmware was the easiest part. Once the bootloader passes control to our code, we initialize clocks and UART. After that we send two marker bytes to indicate beginning of the firmware and then simply read all the flash memory starting from the address 0x08000000 and send it over UART one byte at a time. Since I was too lazy to implement any flow control, I opted for modest 9600 baud and added a small delay after each byte transfer just to make sure that I don’t hit a buffer overrun on my UART-USB converter. TX pin on UART2 is PA2 (there are solder-bridges for RX and TX on Discovery boards).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    clock_setup();</div><div class="line">    usart_setup();</div><div class="line">    gpio_set_mode(GPIOA, GPIO_MODE_OUTPUT_50_MHZ,</div><div class="line">            GPIO_CNF_OUTPUT_PUSHPULL, LED_PIN);</div><div class="line">    gpio_clear(GPIOA, LED_PIN);</div><div class="line"></div><div class="line">    usart_send_blocking(USART2, <span class="number">0xAB</span>);</div><div class="line">    usart_send_blocking(USART2, <span class="number">0xCD</span>);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> addr = <span class="number">0x08000000</span>; addr &lt;= <span class="number">0x08010000</span>; addr++) &#123;</div><div class="line">        usart_send_blocking(USART2, *((<span class="keyword">uint16_t</span> *) addr));</div><div class="line">        delay(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">/* loop forever */</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>After I accidentally triggered mass-erase on my Nucleo board, I had only one board with ST-Link v2-1 left. I didn’t want to risk, so I tried dumping a Chinese ST-Link v2 clone first. Once the update process finished, the programmer immediately started to spit out it’s own flash contents over the serial interface.</p>
<img src="/blog/reverse-engineering-stlink-firmware-part2/stlink_dump.png" alt="note: screenshot shows dumping of ST-Link v2-1" title="note: screenshot shows dumping of ST-Link v2-1">
<p>As I mentioned before, visualizing raw binary data is a very useful trick during analysis. Let’s see what the dump looks like.</p>
<img src="/blog/reverse-engineering-stlink-firmware-part2/dump_visualization.png" alt="Firmware dump visualization" title="Firmware dump visualization">
<p>We clearly see the separation between the bootloader and user code. Most importantly, there is a small chunk of data near the end of the bootloader section (later I discovered these bytes are written by the bootloader at the end of the update process to indicate a valid firmware). We can also see that first two pages of memory in the user code section were erased and now contain our dumper code.</p>
<p>As I mentioned in Part 1, my attempt to access the microcontroller through a debugger resulted in flash mass-erase. According to the reference manual, it implies that Level 1 protection is activated: <em>“Level 1 protection allows to recover a programmed part by erasing the entire Flash content. This is done by re-programming the RDP option byte from Level 1 to Level 0.”</em> The <a href="http://www.st.com/content/ccc/resource/technical/document/programming_manual/10/98/e8/d4/2b/51/4b/f5/CD00283419.pdf/files/CD00283419.pdf/jcr:content/translations/en.CD00283419.pdf" target="_blank" rel="external">programming manual</a> tells us where the option bytes are located.</p>
<img src="/blog/reverse-engineering-stlink-firmware-part2/option_bytes.png" alt="" ""="" title="">
<p>Before we move on to reverse-engineering the binary, let’s extract the bootloader section first, excluding the version bytes near the end:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cat stlink_v2_dump.bin | head -c 15360 &gt; ST-Link_bootloader.bin</div></pre></td></tr></table></figure></p>
<p>At this point, flashing bootloader onto an empty microcontroller will make the update utility think a blank ST-Link is connected. It will let you choose which firmware to flash, however the results will not be any different from what we achieved before by tricking the updater into flashing a different firmware.</p>
<h2 id="Reverse-engineering"><a href="#Reverse-engineering" class="headerlink" title="Reverse-engineering"></a>Reverse-engineering</h2><p>There are many disassemblers available for ARM out there. One of them even works. Unfortunately, IDA demo version does not support binary files. I tried using radare2, but after a while decided that I don’t have a spare lifetime to learn how to use all of it’s hot-keys and commands.</p>
<p>Eventually, I came across Hopper, which is a cross-platform disassembler. Demo version is limited to 30min sessions and does not allow saving projects or exporting files. That seemed good enough for me, so I gave it a try.</p>
<p>First things first, I searched for <code>0x1FFFF800</code> and sure enough - this constant was present.</p>
<img src="/blog/reverse-engineering-stlink-firmware-part2/hopper.png" alt="Hopper" title="Hopper">
<p>It is referenced only once (hitting <code>X</code> lists all the references). If we follow the reference, we end up in a subroutine that presumably sets up the option bytes. Hopper can also generate pseudo-code. It’s not that great with loops and conditionals, but comes in handy when analyzing arithmetic operations.<br><img src="/blog/reverse-engineering-stlink-firmware-part2/set_option_bytes.png" alt="Pseudo-code" title="Pseudo-code"></p>
<p>This function is called only once, and if we follow the reference we end up in a section with quite a few function calls. Control flow graph shows that we identified main program loop at 0x2198. I tried visiting all the functions and guessing what they do.</p>
<img src="/blog/reverse-engineering-stlink-firmware-part2/main_loop.png" alt="Main loop" title="Main loop">
<h2 id="Disabling-protection"><a href="#Disabling-protection" class="headerlink" title="Disabling protection"></a>Disabling protection</h2><p>We know that the function call to <code>option_bytes_config</code> is located at 0x21B2 in the binary dump. Let’s try to ‘nop’ it and see what we get. NOP is a pseudo-instruction on ARM cores, so we have to use something like ‘mov r8,r8’ to skip a cycle.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">echo</span> <span class="string">"mov r8, r8"</span> | arm-none-eabi-as -mthumb -march=armv7 &amp;&amp; arm-none-eabi-objdump <span class="_">-d</span> a.out</div><div class="line">...</div><div class="line">   0:   46c0            nop                     ; (mov r8, r8)</div></pre></td></tr></table></figure>
<p>Branch instruction occupies 4 bytes, which means we have to patch <code>C0 46 C0 46</code> to ‘nop’ the function call.</p>
<p>Next we flash the patched bootloader and use the updater utility to upload ST-Link firmware. Now let’s try dumping the firmware with openocd to see if protection is still enabled.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ openocd <span class="_">-f</span> interface/stlink-v2.cfg -c <span class="string">'transport select hla_swd'</span> \</div><div class="line">          <span class="_">-f</span> target/stm32f1x.cfg -c <span class="string">'adapter_khz 4000'</span> -c init -c <span class="string">'reset halt'</span> \</div><div class="line">          -c <span class="string">'dump_image dump.bin 0x08000000 0x10000'</span> -c shutdown</div></pre></td></tr></table></figure>
<p>And this is what we get:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">stm32f1x.cpu: target state: halted</div><div class="line">target halted due to debug-request, current mode: Thread</div><div class="line">xPSR: 0x01000000 pc: 0x08002764 msp: 0x20000800</div><div class="line">dumped 65536 bytes in 0.427944s (149.552 KiB/s)</div></pre></td></tr></table></figure></p>
<p>Success!</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>After I dumped the firmware from the ST-Link v2 clone I successfully repeated the same procedure for an ST-Link v2-1. I used the same approach for removing protection, although the main program loop was a bit trickier to find. Being able to use a debugger makes it significantly easier to study the functionality of the bootloader and main firmware.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This is the second part of ST-Link reverse-engineering, where I cover dumping the firmware, extracting and reverse-engineering the bootloader, and finally, patching the bootloader in order to disable Level 1 protection.&lt;/p&gt;
    
    </summary>
    
    
      <category term="reverse-engineering" scheme="http://lujji.github.io/blog/tags/reverse-engineering/"/>
    
      <category term="st-link" scheme="http://lujji.github.io/blog/tags/st-link/"/>
    
  </entry>
  
  <entry>
    <title>Reverse-engineering ST-Link firmware</title>
    <link href="http://lujji.github.io/blog/reverse-engineering-stlink-firmware/"/>
    <id>http://lujji.github.io/blog/reverse-engineering-stlink-firmware/</id>
    <published>2016-10-13T01:11:48.000Z</published>
    <updated>2016-10-16T03:27:47.236Z</updated>
    
    <content type="html"><![CDATA[<p>This is the first part of ST-Link reverse-engineering, where I cover analyzing and decompiling the updater utility, decrypting and encrypting firmware binaries and running custom code on ST-Link v2/2-1 programmer.</p>
<a id="more"></a>
<hr>
<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>ST-Link 2 is a neat programmer. It can program, debug and even supports SWO Trace. The more I use it, the more I seem to forget about this <a href="abomination.jpg">abomination</a>. Recently, I came across a Nucleo board with an ST-Link v2-1, which in addition to all the regular features acts as a virtual COM port (VCP) and supports drag-n-drop upload. Sweet! Although I wasn’t very excited about the drag-n-drop thing, having UART for debugging on the same board comes in real handy. After studying the schematics I realized that the programmer is pretty much identical to a regular ST-Link v2 in terms of hardware. The only big difference is that v2-1 uses an MCU with 128k of flash versus 64k on v2 programmer. That made me think if there are any ways of getting UART on a ‘regular’ ST-Link. And so it began..</p>
<h2 id="Research"><a href="#Research" class="headerlink" title="Research"></a>Research</h2><p>EEVBlog forum user <code>eliocor</code> was kind enough to help and did a lot of research on the topic. He pointed me towards <a href="https://my.st.com/public/STe2ecommunities/mcu/Lists/cortex_mx_stm32/Flat.aspx?RootFolder=%2Fpublic%2FSTe2ecommunities%2Fmcu%2FLists%2Fcortex_mx_stm32%2FDifference%20between%20ST-LINKV2-1%20and%20ST-LINKV2&amp;FolderCTID=0x01200200770978C69A1141439FE559EB459D7580009C4E14902C3CDE46A77F0FFD06506F5B&amp;currentviews=194" target="_blank" rel="external">this</a> discussion on the ST forums. According to the ST employee, there are 4 versions of ST-Link 2: ST-Link/v2, ST-Link/v2-A, ST-Link/v2-B and ST-Link/v2-1. Presumably, A, B and 2-1 versions all have UART support and a different bootloader. ST-Link/v2-1 also uses a larger MCU. Looking at windows drivers reveals a number of different PID combinations.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">VID_0483&amp;PID_3748</div><div class="line">VID_0483&amp;PID_374A&amp;MI_00</div><div class="line">VID_0483&amp;PID_374B&amp;MI_00</div><div class="line">VID_0483&amp;PID_374A&amp;MI_01</div></pre></td></tr></table></figure>
<p>Initially, I tried connecting to the MCU with J-Link and see if we get anything useful. I launched J-Link Commander, typed ‘connect’ and was very surprised.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Active read protected STM32 device detected. This could cause problems during flash download.</div><div class="line">Device will be unsecured now.</div><div class="line">Note: Unsecuring will trigger a mass erase of the internal flash.</div></pre></td></tr></table></figure>
<p>MCU committed suicide. Flash was completely erased and I lost my ST-Link. Apparently, J-Link linux utility was ‘kind’ enough to remove option bytes without even asking the user.</p>
<p>Despite the fact that I lost my programmer, I still learned some useful information. Being able to unsecure the chip by erasing the flash contents suggests that Level 1 protection is active (more on that in Part 2).</p>
<h2 id="Analyzing-the-updater"><a href="#Analyzing-the-updater" class="headerlink" title="Analyzing the updater"></a>Analyzing the updater</h2><p>There is an article by Taylor Killian written in 2013, which covers extracting ST-Link firmware from the updater executable. At first I tried following the author’s approach and disassembling the windows executable. I searched for string references and soon found a part of code that decides which firmware to flash based on the ID of the programmer. It was implemented as a switch statement and the disassembly looked like a simple jump table. I fiddled around with various conditional jumps and was able to ‘help’ the program flash a different firmware into the programmer. After a few attempts I detached st-link from the virtual box and dmesg greeted me with the following:</p>
<img src="/blog/reverse-engineering-stlink-firmware/dmesg.png" alt="" ""="" title="">
<p>Hah, piece of cake! I tried opening /dev/ttyACM2 - no errors. Then I connected a dev-board and tried flashing it with my upgraded st-link. It didn’t work. The official flash utility failed with ‘ST-Link USB error’ and openocd refused to see the programmer at all. Moreover, when I unplugged and reattached st-link, CDC interface was gone. For some reason st-link refused to exit DFU mode.</p>
<p>I played around with windows update utility but quickly got bored. Luckily, ST were kind enough to have a cross-platform updater written in java, so that we no longer have to fire up a virtual machine just to update the firmware.</p>
<p>Extracting STLinkUpgrade.jar reveals some interesting binaries. I tried to match them with corresponding labels from the updater:</p>
<ul>
<li><strong>f1_x.bin</strong>: ST-Link v1 firmwares. Not interested.</li>
<li><strong>f2_1.bin</strong>: “STM32 only”. Appears to be for Discovery boards.</li>
<li><strong>f2_2.bin</strong>: “STM8 only”. Also not interested.</li>
<li><strong>f2_3.bin</strong>: “STM32+STM8”. Standalone programmer, also used in Chinese clones.</li>
<li><strong>f2_4.bin</strong>: “STM32+MSD+VCP”. This one is for ST-Link v2-1 found on Nucleo boards.</li>
<li><strong>f2_5.bin</strong>: “STM32+Audio”. No idea.</li>
</ul>
<p>So the firmware with UART support is obviously f2_4, but there is a slight problem: ST-Link v2-1 on a Nucleo board features an STM32F103CBT6 microcontroller with 128k of flash, so it’s unlikely that we’ll ever manage to squeeze it into an F103C8. The firmware I’m most interested in is f2_5 (“STM32+Audio”) - I have no idea what “Audio” means, but we know that there are at least two versions of ST-Link with UART capability so, presumably, this firmware is for one of them.</p>
<p>The first obvious step was to rename these files inside the .jar archive and make the updater flash the firmware that we want. Unfortunately, the results were the same as with patching the windows executable.</p>
<p>The next step was to figure out what format these files have. When working with unknown data, it’s always a good idea to have a visual representation of some sort. Judging by the uniform distribution of data we can suspect some encryption or archiving involved.</p>
<img src="/blog/reverse-engineering-stlink-firmware/histogram.png" alt="Histogram of firmware data" title="Histogram of firmware data">
<p>Now, it’s no secret that these binaries are encrypted with AES-128 and the key is stored inside the executable in plain ASCII, which was covered in the article I mentioned earlier. However, since I was planning to use the application itself to perform encryption/decryption, this information was of little use to me. So without any further investigation I went on to decompiling the updater utility.</p>
<p>I used <a href="https://bitbucket.org/mstrobel/procyon/downloads" target="_blank" rel="external">procyon decompiler</a>, reconstructed function calls and after a while was able to decrypt the firmware binary. Encryption key was <del>“worst HAL libraries”</del> “best performance”. Finally, I’ve hacked everything into a command-line utility, which is able to encrypt and decrypt binary images (code is available on <a href="https://github.com/lujji/st-decrypt" target="_blank" rel="external">github</a>).</p>
<p>Let’s take a look at the decrypted file and search for known Unicode strings.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">0x00008ee0: 80 14 00 20 04 03 09 04 26 03 53 00 54 00 4d 00  ... ....&amp;.S.T.M.</div><div class="line">0x00008ef0: 69 00 63 00 72 00 6f 00 65 00 6c 00 65 00 63 00  i.c.r.o.e.l.e.c.</div><div class="line">0x00008f00: 74 00 72 00 6f 00 6e 00 69 00 63 00 73 00 00 00  t.r.o.n.i.c.s...</div><div class="line">0x00008f10: 1a 03 53 00 54 00 4d 00 33 00 32 00 20 00 53 00  ..S.T.M.3.2. .S.</div><div class="line">0x00008f20: 54 00 4c 00 69 00 6e 00 6b 00 00 00 1c 03 53 00  T.L.i.n.k.....S.</div><div class="line">0x00008f30: 54 00 2d 00 4c 00 69 00 6e 00 6b 00 20 00 44 00  T.-.L.i.n.k. .D.</div><div class="line">0x00008f40: 65 00 62 00 75 00 67 00 2d e9 f8 4f 00 24 fe f7  e.b.u.g.-..O.$..</div><div class="line">0x00008f50: 3d fa 82 46 00 22 4f f4 fa 61 04 20 fb f7 ee fc  =..F.&quot;O..a. ....</div></pre></td></tr></table></figure>
<p>Looks promissing, right? ;)</p>
<p>The next step was to change something in the decrypted firmware, encrypt it and send back to the device. It worked flawlessly. As a sanity check, I tried various combinations, including flashing a firmware consisting entirely of 0xFF bytes, just to make sure that the firmware is indeed accepted and written to the device.</p>
<p>At this point I was not interested in analyzing the firmware any further. I realized that the bootloader plays an important role, and I won’t be able to proceed without obtaining it.</p>
<h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello, world"></a>Hello, world</h2><p>Knowing how to encrypt the firmware, I could flash anything I want. However, I had no idea how the bootloader decides whether or not the firmware is OK before it passes control to it. Therefore, I needed to test if the code would actually get executed on the device.</p>
<p>I decided to write a ‘Hello world’ program that would blink an LED on PA5 (SWCLK on the SWD connector). The first thing to do was to alter the linker script and offset the ROM section by the size of the bootloader section.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">MEMORY</div><div class="line">&#123;</div><div class="line">    rom (rx) : ORIGIN = 0x08004000, LENGTH = 64K - 0x4000</div><div class="line">    ram (rwx) : ORIGIN = 0x20000000, LENGTH = 20K</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>The code is rather self-explanatory.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    rcc_clock_setup_in_hse_8mhz_out_72mhz();</div><div class="line">    rcc_periph_clock_enable(RCC_GPIOA);</div><div class="line">    gpio_set_mode(GPIOA, GPIO_MODE_OUTPUT_50_MHZ,</div><div class="line">        GPIO_CNF_OUTPUT_PUSHPULL, GPIO5);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        gpio_toggle(GPIOA, GPIO5);</div><div class="line">        delay_ms(<span class="number">250</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>After compiling the binary I used my utility to encrypt the binary.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ java -jar st_decrypt.jar -k <span class="string">"best performance"</span> -i main.bin -o f2_3.bin --encrypt</div></pre></td></tr></table></figure>
<p>Next, we replace the original <code>f2_3.bin</code> with our own, compress the jar archive and update the firmware on the st-link. For this test I used my F4 Discovery board. The update process finishes with an error saying that it can’t exit DFU mode. Let’s take a look at the board now.</p>
<img src="/blog/reverse-engineering-stlink-firmware/blinking_led.jpg" alt="Current limiting? Never heard of." title="Current limiting? Never heard of.">
<p>It was the first time I was excited about a blinking LED on a development board ;) Once you unplug the power, st-link would start in DFU mode again (as it normally does). Each st-link related command like writing to flash or reading target voltage would first ask the st-link to exit DFU mode and start executing main firmware code.</p>
<p>Now I have a way of executing my own code on the programmer. The next obvious step is to retrieve the bootloader, which I’ll cover in Part 2.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This is the first part of ST-Link reverse-engineering, where I cover analyzing and decompiling the updater utility, decrypting and encrypting firmware binaries and running custom code on ST-Link v2/2-1 programmer.&lt;/p&gt;
    
    </summary>
    
    
      <category term="reverse-engineering" scheme="http://lujji.github.io/blog/tags/reverse-engineering/"/>
    
      <category term="st-link" scheme="http://lujji.github.io/blog/tags/st-link/"/>
    
  </entry>
  
  <entry>
    <title>Adding Trace support to ST-Link clones</title>
    <link href="http://lujji.github.io/blog/stlink-clone-trace/"/>
    <id>http://lujji.github.io/blog/stlink-clone-trace/</id>
    <published>2016-09-10T20:54:00.000Z</published>
    <updated>2016-10-13T01:56:37.352Z</updated>
    
    <content type="html"><![CDATA[<p>When it comes to programming ST microcontrollers, I prefer to use Discovery boards (mainly because you can <a href="https://www.segger.com/jlink-st-link.html" target="_blank" rel="external">turn them into J-Link</a>). However, I got tired of carrying around the whole dev-board just for the programmer, so I ordered a cheap st-link clone due to it’s small form-factor.<br><a id="more"></a></p>
<h2 id="The-clone"><a href="#The-clone" class="headerlink" title="The clone"></a>The clone</h2><img src="/blog/stlink-clone-trace/st-link.jpg" alt="ST-Link clone" title="ST-Link clone">
<p>For less than 3$ you get a nice dongle in aluminium case and some wires. After taking a closer look I noticed that there is no <strong>SWO</strong> pin on the pinout. Perhaps SWIM pin would dual-function as SWO when working with STM32? Unfortunately this wasn’t the case. So what, does it mean I have to use another USB cable just for UART? No way, I’m not going back to the stone age, I want my Trace!</p>
<h2 id="Research"><a href="#Research" class="headerlink" title="Research"></a>Research</h2><p>Trace is a very neat feature. One of the common uses is redirecting <code>stdout</code> stream to stimulus port 0 in order to printf debugging information. All recent versions of ST-Link v2 support this feature, so the first thing I did was check if the dongle is running the original ST-Link firmware. I launched ST-LINK Utility and updated the firmware with no issues whatsoever. So now we know that the dongle is running the latest official firmware and supports trace functionality.</p>
<img src="/blog/stlink-clone-trace/schematic.png" alt="ST-Link schematic" title="ST-Link schematic">
<p>I couldn’t find schematics for a stand-alone programmer so I assumed it would be identical to the one present on Discovery board. PA10 is used for SWO so the next step would be pretty straight-forward.</p>
<h2 id="Modding"><a href="#Modding" class="headerlink" title="Modding"></a>Modding</h2><img src="/blog/stlink-clone-trace/st-link-mod.jpg" alt="5V pin converted into SWO" title="5V pin converted into SWO">
<p>I’ve cut the trace from 5V pin right after the via and soldered some bodge-wire to PA10 (pin 31). I also added a 22&#937; resistor in case something goes horribly wrong. Initially I wanted to use SWIM pin since I don’t care about STM8 and it would only require desoldering one resistor without cutting any traces, but the 5V pin was easier to reach.</p>
<p>Time for some testing.<br><img src="/blog/stlink-clone-trace/trace-screenshot.png" alt="" ""="" title=""></p>
<p>SWO Trace works perfectly fine which makes the dongle much more useful.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;When it comes to programming ST microcontrollers, I prefer to use Discovery boards (mainly because you can &lt;a href=&quot;https://www.segger.com/jlink-st-link.html&quot;&gt;turn them into J-Link&lt;/a&gt;). However, I got tired of carrying around the whole dev-board just for the programmer, so I ordered a cheap st-link clone due to it’s small form-factor.&lt;br&gt;
    
    </summary>
    
    
      <category term="st-link" scheme="http://lujji.github.io/blog/tags/st-link/"/>
    
      <category term="stm32" scheme="http://lujji.github.io/blog/tags/stm32/"/>
    
      <category term="trace" scheme="http://lujji.github.io/blog/tags/trace/"/>
    
      <category term="swo" scheme="http://lujji.github.io/blog/tags/swo/"/>
    
  </entry>
  
</feed>
